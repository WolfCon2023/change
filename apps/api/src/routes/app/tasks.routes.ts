/**
 * Tasks Routes
 * Task management for business operations
 */

import { Router } from 'express';
import type { Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import { BusinessProfile } from '../../db/models/index.js';

const router = Router();

// Simple task schema for embedded tasks (stored in business profile)
// This avoids the workflow dependency of the full Task model

/**
 * GET /app/tasks
 * Get all tasks for the current user's business
 */
router.get('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    
    if (!tenantId) {
      return res.status(400).json({
        success: false,
        error: { code: 'NO_TENANT', message: 'User must belong to a tenant' },
      });
    }
    
    // Get business profile with tasks
    const profile = await BusinessProfile.findOne({ tenantId }).lean();
    if (!profile) {
      return res.status(404).json({
        success: false,
        error: { code: 'NO_PROFILE', message: 'Business profile not found' },
      });
    }
    
    // Get tasks from profile or generate default tasks based on status
    let tasks = (profile as any).tasks || [];
    
    // If no tasks exist, generate default tasks based on business progress
    if (tasks.length === 0) {
      tasks = generateDefaultTasks(profile);
      
      // Save generated tasks to profile
      await BusinessProfile.updateOne(
        { tenantId },
        { $set: { tasks } }
      );
    }
    
    // Sort tasks: incomplete first, then by due date
    const sortedTasks = [...tasks].sort((a: any, b: any) => {
      if (a.status === 'completed' && b.status !== 'completed') return 1;
      if (a.status !== 'completed' && b.status === 'completed') return -1;
      if (a.dueDate && b.dueDate) {
        return new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime();
      }
      return a.order - b.order;
    });
    
    // Calculate stats
    const stats = {
      total: tasks.length,
      pending: tasks.filter((t: any) => t.status === 'pending').length,
      inProgress: tasks.filter((t: any) => t.status === 'in_progress').length,
      completed: tasks.filter((t: any) => t.status === 'completed').length,
      overdue: tasks.filter((t: any) => {
        if (t.status === 'completed' || !t.dueDate) return false;
        return new Date(t.dueDate) < new Date();
      }).length,
    };
    
    res.json({
      success: true,
      data: {
        tasks: sortedTasks,
        stats,
      },
      meta: { timestamp: new Date().toISOString() },
    });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /app/tasks
 * Create a new task
 */
router.post('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    const userId = req.user?.userId;
    
    if (!tenantId) {
      return res.status(400).json({
        success: false,
        error: { code: 'NO_TENANT', message: 'User must belong to a tenant' },
      });
    }
    
    const { title, description, category, priority, dueDate } = req.body;
    
    if (!title) {
      return res.status(400).json({
        success: false,
        error: { code: 'VALIDATION_ERROR', message: 'Title is required' },
      });
    }
    
    const newTask = {
      id: new mongoose.Types.ObjectId().toString(),
      title,
      description: description || '',
      category: category || 'general',
      status: 'pending',
      priority: priority || 'medium',
      dueDate: dueDate || null,
      isAutoGenerated: false,
      order: Date.now(),
      createdAt: new Date().toISOString(),
      createdBy: userId,
    };
    
    const result = await BusinessProfile.updateOne(
      { tenantId },
      { $push: { tasks: newTask } }
    );
    
    if (result.modifiedCount === 0) {
      return res.status(404).json({
        success: false,
        error: { code: 'NO_PROFILE', message: 'Business profile not found' },
      });
    }
    
    res.status(201).json({
      success: true,
      data: newTask,
      meta: { timestamp: new Date().toISOString() },
    });
  } catch (error) {
    next(error);
  }
});

/**
 * PUT /app/tasks/:id
 * Update a task
 */
router.put('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    const userId = req.user?.userId;
    const { id } = req.params;
    
    if (!tenantId) {
      return res.status(400).json({
        success: false,
        error: { code: 'NO_TENANT', message: 'User must belong to a tenant' },
      });
    }
    
    const { title, description, status, priority, dueDate } = req.body;
    
    // Build update object
    const updateFields: any = {};
    if (title !== undefined) updateFields['tasks.$.title'] = title;
    if (description !== undefined) updateFields['tasks.$.description'] = description;
    if (status !== undefined) {
      updateFields['tasks.$.status'] = status;
      if (status === 'completed') {
        updateFields['tasks.$.completedAt'] = new Date().toISOString();
        updateFields['tasks.$.completedBy'] = userId;
      }
    }
    if (priority !== undefined) updateFields['tasks.$.priority'] = priority;
    if (dueDate !== undefined) updateFields['tasks.$.dueDate'] = dueDate;
    updateFields['tasks.$.updatedAt'] = new Date().toISOString();
    
    const result = await BusinessProfile.updateOne(
      { tenantId, 'tasks.id': id },
      { $set: updateFields }
    );
    
    if (result.modifiedCount === 0) {
      return res.status(404).json({
        success: false,
        error: { code: 'NOT_FOUND', message: 'Task not found' },
      });
    }
    
    // Get updated task
    const profile = await BusinessProfile.findOne({ tenantId }).lean();
    const updatedTask = (profile as any)?.tasks?.find((t: any) => t.id === id);
    
    res.json({
      success: true,
      data: updatedTask,
      meta: { timestamp: new Date().toISOString() },
    });
  } catch (error) {
    next(error);
  }
});

/**
 * DELETE /app/tasks/:id
 * Delete a task
 */
router.delete('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    const { id } = req.params;
    
    if (!tenantId) {
      return res.status(400).json({
        success: false,
        error: { code: 'NO_TENANT', message: 'User must belong to a tenant' },
      });
    }
    
    const result = await BusinessProfile.updateOne(
      { tenantId },
      { $pull: { tasks: { id } } }
    );
    
    if (result.modifiedCount === 0) {
      return res.status(404).json({
        success: false,
        error: { code: 'NOT_FOUND', message: 'Task not found' },
      });
    }
    
    res.json({
      success: true,
      message: 'Task deleted successfully',
      meta: { timestamp: new Date().toISOString() },
    });
  } catch (error) {
    next(error);
  }
});

/**
 * Generate default tasks based on business profile status
 */
function generateDefaultTasks(profile: any): any[] {
  const tasks: any[] = [];
  const flags = profile.readinessFlags || {};
  const today = new Date();
  let order = 0;
  
  // Setup tasks
  if (!flags.archetypeSelected) {
    tasks.push(createTask('Select business archetype', 'Choose the type of business you\'re starting', 'setup', 'high', order++));
  }
  if (!flags.entitySelected) {
    tasks.push(createTask('Choose entity type', 'Select LLC, Corporation, or other entity structure', 'setup', 'high', order++));
  }
  if (!flags.stateSelected) {
    tasks.push(createTask('Select formation state', 'Choose the state where your business will be formed', 'setup', 'high', order++));
  }
  
  // Formation tasks
  if (!flags.addressVerified) {
    tasks.push(createTask('Add business address', 'Provide your principal business address', 'formation', 'high', order++));
  }
  if (!flags.registeredAgentSet) {
    tasks.push(createTask('Set up registered agent', 'Designate a registered agent for legal documents', 'formation', 'high', order++));
  }
  if (!flags.ownersAdded) {
    tasks.push(createTask('Add owners/members', 'Add the people who will own your business', 'formation', 'medium', order++));
  }
  if (profile.formationStatus !== 'filed' && profile.formationStatus !== 'approved') {
    tasks.push(createTask('File formation documents', 'Submit your Articles of Organization/Incorporation', 'formation', 'high', order++));
  }
  if (profile.einStatus !== 'received') {
    tasks.push(createTask('Apply for EIN', 'Get your Employer Identification Number from the IRS', 'formation', 'high', order++));
  }
  
  // Operations tasks
  if (!flags.bankAccountOpened) {
    tasks.push(createTask('Open business bank account', 'Separate your business and personal finances', 'operations', 'high', order++));
  }
  if (!flags.operatingAgreementSigned) {
    const docName = profile.businessType?.toLowerCase().includes('llc') ? 'Operating Agreement' : 'Bylaws';
    tasks.push(createTask(`Complete ${docName}`, `Create and sign your ${docName.toLowerCase()}`, 'operations', 'high', order++));
  }
  if (!flags.complianceCalendarSetup) {
    tasks.push(createTask('Set up compliance calendar', 'Track important deadlines and filings', 'operations', 'medium', order++));
  }
  
  // Mark completed tasks
  if (flags.archetypeSelected) markComplete(tasks, 'Select business archetype');
  if (flags.entitySelected) markComplete(tasks, 'Choose entity type');
  if (flags.stateSelected) markComplete(tasks, 'Select formation state');
  if (flags.addressVerified) markComplete(tasks, 'Add business address');
  if (flags.registeredAgentSet) markComplete(tasks, 'Set up registered agent');
  if (flags.ownersAdded) markComplete(tasks, 'Add owners/members');
  if (profile.formationStatus === 'filed' || profile.formationStatus === 'approved') {
    markComplete(tasks, 'File formation documents');
  }
  if (profile.einStatus === 'received') markComplete(tasks, 'Apply for EIN');
  if (flags.bankAccountOpened) markComplete(tasks, 'Open business bank account');
  if (flags.operatingAgreementSigned) {
    const docName = profile.businessType?.toLowerCase().includes('llc') ? 'Operating Agreement' : 'Bylaws';
    markComplete(tasks, `Complete ${docName}`);
  }
  if (flags.complianceCalendarSetup) markComplete(tasks, 'Set up compliance calendar');
  
  return tasks;
}

function createTask(title: string, description: string, category: string, priority: string, order: number): any {
  return {
    id: new mongoose.Types.ObjectId().toString(),
    title,
    description,
    category,
    status: 'pending',
    priority,
    dueDate: null,
    isAutoGenerated: true,
    order,
    createdAt: new Date().toISOString(),
  };
}

function markComplete(tasks: any[], title: string): void {
  const task = tasks.find(t => t.title === title);
  if (task) {
    task.status = 'completed';
    task.completedAt = new Date().toISOString();
  }
}

export default router;
